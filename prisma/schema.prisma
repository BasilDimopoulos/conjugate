generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["windows", "rhel-openssl-3.0.x", "rhel-openssl-1.0.x", "darwin-arm64"]
}

datasource db {
  provider     = "postgresql"
  url          = env("DATABASE_URL")
  relationMode = "prisma"
}

model User {
  id              String   @id @default(uuid())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  clerkId         String?  @unique
  redisId         String?
  email           String   @unique
  mostRecentSkill String?

  skills    UsersSkills[]
  UsersWord UsersWord[]

  UserStory UserStory[]
}

model Skill {
  id        String  @id @default(uuid())
  type      String
  name      String
  available Boolean @default(false)
  imageName String

  users UsersSkills[]
}

model UsersSkills {
  id      String   @id @default(uuid())
  skillId String   @unique
  userId  String   @unique
  reasons String[]

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  skill Skill @relation(fields: [skillId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([skillId])
}

model Word {
  id                    String        @id @default(uuid())
  displayText           String
  languageId            String
  imageUrl              String?
  pronunciationUrl      String?
  mnemonic              String?
  funFact               String?
  phoneticTranscription String?
  pinyin                String?
  generationId          String?       @unique
  englishTranslation    String?
  translationsFrom      Translation[] @relation("WordToTranslation")
  translationsTo        Translation[] @relation("TranslatedWordToTranslation")
}

model Language {
  id   String  @id @default(uuid())
  name String
  code String?
}

model UsersWord {
  id             String   @id @default(uuid())
  userId         String
  word           String
  level          Int
  nextReviewTime DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model Translation {
  id               String   @id @default(uuid())
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  wordId           String
  translatedWordId String

  word           Word @relation("WordToTranslation", fields: [wordId], references: [id])
  translatedWord Word @relation("TranslatedWordToTranslation", fields: [translatedWordId], references: [id])

  @@index([wordId])
  @@index([translatedWordId])
}

model Scenario {
  id           String  @id @default(uuid())
  title        String
  startSceneId String // ID of the starting scene
  scenes       Scene[]
}

model Scene {
  id            String         @id @default(uuid())
  scenario      Scenario       @relation(fields: [scenarioId], references: [id])
  scenarioId    String
  dialogues     Dialogue[]
  playerChoices PlayerChoice[]
  imageUrl      String

  PlayerChoice PlayerChoice[] @relation("NextScene")
}

model Dialogue {
  id          String    @id @default(uuid())
  text        String
  character   Character @relation(fields: [characterId], references: [id])
  characterId String
  scene       Scene     @relation(fields: [sceneId], references: [id])
  sceneId     String
}

model Character {
  id        String     @id @default(uuid())
  firstName String
  lastName  String
  imageUrl  String
  lines     Dialogue[] // one-to-many: a character can speak many times
}

model PlayerChoice {
  id   String @id @default(uuid())
  text String

  // Relation to current scene
  scene   Scene  @relation(fields: [sceneId], references: [id])
  sceneId String

  // Relation to next scene
  nextScene   Scene  @relation("NextScene", fields: [nextSceneId], references: [id])
  nextSceneId String

  // Optional fields for conditions/effects
  condition String?
  effects   String?
}

model Story {
  id                     String @id @default(uuid())
  title                  String
  vectorClassificationId String
  imageUrl               String
  description            String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model UserStory {
  id             String      @id @default(uuid())
  userId         String
  storyId        String
  storyLog       StoryLog?
  sceneLog       SceneLog?
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt

  user User @relation(fields: [userId], references: [id])

  Chapter Chapter[]
}

model Chapter {
  id          String    @id @default(uuid())
  userStoryId String
  title       String
  goals       String     // text field for chapter goals
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  userStory   UserStory  @relation(fields: [userStoryId], references: [id])
}

model StoryLog {
  id          String   @id @default(uuid())
  userStoryId String   @unique
  keyMoments  String[] 

  userStory UserStory @relation(fields: [userStoryId], references: [id])
}

model SceneLog {
  id          String   @id @default(uuid())
  userStoryId String @unique
  sceneId     String
  dialoguesSeen String[] // stores dialogue IDs seen

  userStory UserStory @relation(fields: [userStoryId], references: [id])
}
